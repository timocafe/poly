\documentclass[preview]{elsarticle}

\usepackage{amssymb}
\usepackage[table]{xcolor}
\usepackage{subfig}
\usepackage{ytableau}
\usepackage{tikz}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{amsmath}
\usepackage{pgfplots}
\usepackage{mathtools}
\usepackage[linesnumbered,lined,boxed,commentsnumbered]{algorithm2e}
\usetikzlibrary{arrows, calc, positioning, patterns, pgfplots.polar}

\usetikzlibrary{snakes,arrows,shapes}

\title{Polynomial evaluation on super scalar architecture, applied to the elementary function $e^x$}

\author[rvt]{T. Ewart }
\ead{timothee.ewart@epfl.ch}

\author[rvt]{S. Yates}
\ead{sam.yates@epfl.ch}

%\author[rvt]{F.  Sch\"urmann }
%\ead{felix.schuermann@epfl.ch}

\author[rvt]{F. Delalondre}
\ead{fabien.delalondre@epfl.ch}

\author[rvt]{F.  Sch\"urmann }
\ead{felix.schuermann@epfl.ch}


\address[rvt]{Blue Brain Project, Campus Biotech, Ch. des Mines 9. CH-1212 Gen\`eve}


\graphicspath{{plot/figures/}{../res_poly/figures/}{graph/}} %do not forget the / at the end

\newcommand{\R}{\mathbb{R}}


\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\begin{document}

\begin{abstract}

%The polynomial evaluation is a main field of computer science, and it has  been massively studied.
%In this paper, we focused on the benchmarking of the polynomial evaluation of the main algorithms
%of literature on the last processor of IBM and Intel.
%
%Modern processors are super scalar and out of order, therefor the performance of the polynomial evaluation 
%will depend of the degree of parallelism of the algorithm, to maximise
%the pipelines and floating point unit usage. The performance will be achieved, 
%if the algorithm has massive degree of parallelism.
%
%
%The art of polynomial evaluation is well know and well documented in the literature. The performance of a polynomial evaluation
%depends on two factor, the efficiency of the algorithm 


The polynomial evaluation of small degree polynomials is critical for the computation of elementary functions. 
It has been massively studied, and is well documented. In this paper, we have evaluated the existing methods for polynomial evaluation
on super scalar architecture.  And, we have completed this work by factorisation evaluation, which is surprisingly neglected in the literature.  
This work has been focused on the most recent processors of  Intel and IBM, amongst others, several computational units are available.
Moreover, we have applied our work on the elementary $e^x$ that  requires, in the current implementation,
an evaluation  of a polynomial of degree 10 for a satisfying precision.


\end{abstract}


\maketitle

\section{Superscalar processor}
It exists several definition of superscalar processor:  "Dispatch multiple instructions every cycle" from
[CITE Agerwala and Cocke (1987)] or "Execute multiple operations in parallel" from [CITE Lam (1990)].
Whatever the definitions, they are two main ideas: execute instructions concurrently and independently in separate execution pipelines.
Moreover, improve throughput of concurrent pipelines by allowing out-of-order execution. Modern processors have more than one pipepeline.
On the last release of Intel and IBM this number reaches 16 pipelines, and more interesting processors can have several Floating Point Unit (FPU).

Complementary to the execution pipeline, the execution of a single instructions is also pipeline in several step [CITE power7 FPU paper].
It allows to restart the same operation (if no dependency) without waiting the completeness of the previous one.

to be continued ....

This paper focuses on the evaluation on polynomial of degree 10 on super-scalar processor, and \textit{in fine} it's application on the elementary function
$e^x$. State of the art of polynomial is first presented and the elementary function $e^x$. Then, more technically we describe the core unit of the last
processor of Intel (SandyBridge and Broadwell) and IBM (Power7 and Power8), and the different method we will use for coding and measure the veracity of the results.
We present results for the polynomial evaluation and exponential for scalar and vectorial version, and then we compare to vendor exponential library.

\section{State of the art}
In evaluating the polynomial of degree $n$,
 \begin{eqnarray}
   P(x) = a_0 + a_1 x  + \dots + a_{n} x^{n}, \,\, (a_i  \in \R) \label{P0}
 \end{eqnarray}
 a large number of method can be applied. In this study, we selected the most significative, extracted from the great book of Knuth the art of programming [cite vol 2].
 The followings methods have been selected: the Brute Force method, the Horner method from order 1 to $n-1$, the Estrin method. Moreover, the factorisation method has been associated to all the  methods previously enumerated. To improove the performance, the main challenge consists to  maximise the parallelism and minimise the pipelining data hazard, to avoid bubble and consequently deteriorate the performance.
\section{Algorithms}
\subsection{Evaluation of Powers}
The first step to perform polynomial evaluation is the evaluation of the powers.  The simple succession of $x$ multiplication has a  complexity of o($n$).
Following the advice of Knuth, the Right-to-left binary method for exponentiation is the excellent alternative for our small degree polynomial [cite Knuth chapter]. 
The method has a complexity o($\lfloor log(n) \rfloor + \upsilon(n)$) multiplications where  $\upsilon(n)$ number of ones in the binary representation of $n$.
\subsection{Brute force}
The brute force method simply consists to evaluate the polynomial \ref{P0}, term after term, using evaluation of power as described previously.
The complexity of the algorithm is  $n$ additions and  $2n-1$ multiplications.
\subsection{Horner method: classical - $1^{st}$-order}
The Horner method at order one is the most classical. It is also very well know under the name \textit{"Horner's rule"}.
It evaluates recursively the polynomial \ref{P0} at $x = x_0$,
 \begin{eqnarray}
   P(x_0) = a_0 +  x_0 ( a_1  +  x_0 ( a_2 + x_0(  \dots a_{n}  ) ))
  \end{eqnarray}
The \textit{"Horner's rule"} requires a complexity of $n$ multiplications and $n$ additions or $n$ FMA. The method is efficient,
but inefficient for the processor point of view, because, it introduces data hazard pipelining due to the dependency chain in the recursive process.

\subsection{Horner method: $k^{th}$-order}
The  \textit{"Horner's rule"} can be generalised at any order by building new polynomials over $x^k$ [CITE ....].
The main advantage is to introduce parallelism that removes the data hazard specially for high order of $k$
 \begin{eqnarray}
   P(x_0) &=&  Q_0(x_0^k) + Q_1(x_0^k) + \dots + Q_{k-1}(x_0^k) \\
   Q_{k-1}(x_0^k) &=&  x_0^{k-1}(a_{k-1} + x_0^{k}(a_{2k-1} + x_0^{k}(a_{3k-1} + x_0^{k}(\dots a_{m \le n}))))
     \end{eqnarray}
This method has $n+k-1$ multiplications and $n$ additions. $k$ degree of parallelism. The classical Horner method corresponds to $k=1$

\subsection{Horner method: Estrin}
An alternative to the  generalization of Horner's rule is the Estrin method [cite estrin], described as follow:
\begin{eqnarray}
c_i^{(0)} = a_i + x_0  a_{i+1} \\
c_i^n = c_i^{(n-1)} + x_0^{2^n} c_{i+2^n}^{n-1} \\
P(x_0) = c_0^n
\end{eqnarray}
A development of the previous equation look likes 
\begin{eqnarray}
P(x_0) &=&  a_0 + a_1 x_0   \nonumber \\
               &+&  x_0^2(a_2  + a_3 x_0) \nonumber \\
               &+&  x_0^4(a_4  + a_5 x_0 + x_0^2 (a_6 + a_7x_0)) \nonumber \\
               &+&  x_0^8(a_8  + a_9 x_0 + x_0^2 (a_{10} + a_{11}x_0) + x_0^4 ((a_{12}+a_{13}x_0 +x_0^2(a_{14}+a_{15}x_0)))))  \nonumber \\
               & &\dots
\end{eqnarray}
This method has $n$ multiplication and $n$ additions, but it is a remarkable pattern design for two reasons.
Every $c_i^j$ can be associated to an independent FMA,  and as independent it will have a good efficiency on
super scalar machine (no bubble).

\subsection{Factorization}
Finally the last method, we will evaluate is the factorization.  We are looking for polynomials with fix coefficients. We compute
the root of the polynomial using an outside program.  The roots are recombined into produce of linear polynomial or  quadratic if the root
are complex. From the linear or quadratic, new polynomial can be constructed. At the end every "new" polynomial can be evaluated by one 
of the previous described method. This method can introduce a large parallelism and may outperform for superscalar architecture.

\subsection{number of operations}
To conclude this section on algorithm, the complexity of the different method are summarized  in the table \ref{complexity}.
\begin{table}[h!]
\begin{center}
\begin{tabular}{l c c  }
	\hline
		             & addition & multiplication \\
Brute force            &  $n$       & $2n-1$     \\
Horner $k^{th}$-order  & $n+k-1$ & $n$   \\
Estrin                    & $n$        & $n$             \\
Factorization        &    combinaison            &   combinaison   \\    
	\hline
\end{tabular}
\end{center}
\caption{ number of operation of the different algorithms of evaluation of the polynomial of degree $n$. \label{complexity}}
\end{table}%

\subsection{Notations}
In this section, the following notations are introduced. Any polynomial $P$ is characterised by two parameters, the degree and the method of evaluation. 
The degree like usual is presented by the indices $n$  whereas the subscript is the method of evaluation. The different method of evaluation are
the brute force method ($b$), the Horner method at the $k$ order ($h^k$) and Estrin method ($e$). Finally, $P^{6}_{e}$ means a polynomial of degree 6
evaluated with the method of Estrin. An other example $P^8_{h^2}$ means a polynomial of degree 8 evaluated with the method of Horner at the order 2.

\subsection{Combinatory}

In this study, we are focusing on polynomial evaluation more specially on a specific polynomial of degree 10 where the coefficients are know in advanced. This polynomial 
is the approximation of $e^x$ with $x \in [0, ln2]$. This polynomial is strictly positive in this range, consequently, it does not have any real roots, but five pairs of conjugate
root. From the 5 pairs, 5 quadratics polynomial can be built. The product of this 5 quadratics is a factorisation scheme. However, it exists a lot of alternative scheme.
The starting point of the evaluation is the partition of 10 into even summands which is equivalent of the decomposition of 5 "multiply by 2". In other words the seven partition 
of 5 are $(5),(4,1),(3,2),(3,1^2),(2^2,1),(2,1^3),(1^5)$ and consequently the partition of 10 into even summands are

\begin{eqnarray}
 (10),\,(8,2),\,(6,4),\,(6,2^2),\,(4^2,2),\,(4,2^3) \textrm{ and } (2^5) \label{evaluation}
\end{eqnarray}

To evaluate the number of combination there are three possibilities:

\begin{enumerate}
\item Each polynomial $P^n$ has $n+1$ method of evaluation: $P^n_b$, $P^n_e$ and $P^n_{h^{kth}}$ where $kth \in [1,n-1]$ because $P^n_{h^1} = P^n_{h^n}$. 
\item Each polynomial produce $P^n P^m$ with $n!=m$, there are $n \times m$ evaluations (we do not consider $P^m P^n$  because the multiplication is commutative)
\item Each polynomial have the same degree $ \prod P^n$ , there are ${m+k-1 \choose k} $  and not ${m \choose k}$ because the repetitions are allowed. $m$ is the number of method 
(so $n+1$) and $k$ is the number of produce.
\end{enumerate}

Apply this scheme to the equation \ref{evaluation} determines the total number of combinations $S$:

\begin{eqnarray}
S  &=&  \textrm{card}((10) + (8,2) + (6,4) + (6,2^2) + (4^2,2) + (4,2^3) + (2^5)) \nonumber \\
    &=& 11 + 9\times3 + 7\times5 + 7\times{4 \choose 2} + 3 \times {6 \choose 2} + 5 \times {5 \choose 3} + {7 \choose 5}  \nonumber \\
    &=& 231
\end{eqnarray}

The total number of combination to evaluate the $P^{10}$ is 231.

\section{Elementary function: $e^x$}
Small polynomials are intensively utilised in elementary functions, the present study focuses on $e^x$. A possible approach to compute $e^x$ is:

$\forall x \in  \mathbb{R}, \exists  y \in [0,ln 2] \textrm{  with } k \in \mathbb{N} \nonumber$
\begin{eqnarray}
    x  & = & y + k ln 2  \label{begin_exp} \nonumber \\
e^x  &= & 2^k e^y \nonumber 
%       &=&  2^k P(y) \label{exponential_formula} 
\end{eqnarray}

The restriction on the range $[0,ln 2]$ simplifies the evaluation of $e^y$. A truncated Taylor series could be a good idea to evaluate $e^y$.
Nevertheless, it's source of large error. If we consider the Taylor series:

\begin{eqnarray}
e^y = \underbrace{\overbrace{1 + y + \frac{y^2}{2!} + \dots + \frac{y^n}{n!}}^{\text{Approximation}} + \overbrace{\frac{y^{n+1}}{n+1!} + \dots}^{\text{Truncation Errors}}}_{\text{Exact mathematical formulation}}
\end{eqnarray}

Here the "Truncation Errors" corresponds of the remainder $R_n$ from the Taylor's Theorem. It can be expressed under an integral or the Lagrange form by:
\begin{eqnarray}
R_n & = & \int_{a}^{y} \frac{(y-t)^n}{n!}f^{(n+1)}(t)dt \,\,\, \text{(the integral form)} \\
	& = & \frac{f^{(n+1)}(c)}{(n+1)!}(y-1)^{n+1}, \,\,\, \forall c \in [a,y] \,\,\, \text{(the Lagrange form)}
\end{eqnarray}
For $f(y)=e^y$ and $a=0$, we have $f^{(n+1)}(y)=e^y$, thus
\begin{eqnarray}
R_n &=& \frac{e^c}{(n+1)!}y^{n+1}, \,\,\, c \in [0,y] \\
       &\leq& \left| \frac{e^y}{(n+1)!} y^{n+1} \right|
\end{eqnarray}

When $y=ln2$ and $n=10$, $R_{10} \leq \left| \frac{e^{ln2}}{11!}ln(2)^{11}\right| \sim 8.89 \times 10^{-10}$, it is a large error. To match an error 
lower than the double precision of the machine, $n=16$ is needed. An alternative will be to develop the Taylor 
series around $ln2/2$ but one more time error will be not uniform.

[copy/past Wolfram]The Remez algorithm (Remez 1934), also called the Remez exchange algorithm, is an application of the Chebyshev alternation theorem that constructs the polynomial of best approximation to certain functions under a number of conditions. The Remez algorithm in effect goes a step beyond the minimax approximation algorithm to give a slightly finer solution to an approximation problem. It is an iterator technique.

The determination of the polynomial is determined by an external program like boost::math::tools package. A polynomial of degree 10 gives total satisfaction.
We will apply the 231 schemes to evaluate it.
 
\subsection{ From x to k and y}
The equation \ref{begin_exp} can be solved  although it has two unknowns.
$\forall x \in  \mathbb{R}, \exists  y \in [0,ln 2] \textrm{  with } k \in \mathbb{N} \nonumber $
\begin{eqnarray}
x & = & y + k ln 2  \nonumber \\
\floor*{\frac{x}{ln2}} & = &  \underbrace{ \floor*{\frac{y}{ln 2}}}_{=0} + \underbrace{\floor*{k}}_{=k} \nonumber \\
			      & = & k 
\end{eqnarray} 
$k$  is determinate and consequently $y$. The previous equations can be integrated in the following algorithm:

\begin{algorithm}[H]
 \KwData{$x$ floating point number}
 \KwResult{$k$ signed integer and $y$ floating point number}
$ k =  \floor*{\frac{x}{ln2}} $ \;
\tcc{For rounding issue $-k \times ln2$ correction: in two steps}
$y = x - k\times6.93145751953125 \times  10^{-1}$\;
$y = x - k\times1.42860682030941723212  \times 10^{-6}$\;
 \textbf{return} $k$ and $y$\;
 \caption{$2^k$ evaluation algorithm. Note the operation  interpret\_as\_double interprets $k$ as a double it is not a cast operation.}
\end{algorithm}

\subsection{$2^k$ fast evaluation}
Compute $2^k$ may be done with a left bit shift but it can only work until 63 and it necessitates a cast from integer to double (compute intensive instruction). 
An alternative solution utilises the floating point representation. Rational number can be represented closely under the following form:

\begin{eqnarray}
x = -1^s \times (1+F) \times 2^{e+bias}
\end{eqnarray}


\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.4]{618px-IEEE_754_Double_Floating_Point_Format} 
\caption{double precision floating point number using IEEE-754 norm \label{doubleIEEE}}
\end{center}
\end{figure}

For double precision number (Figure \ref{doubleIEEE}): $s$ sign bit, $e + bias $ is the exponent (11 bits), it is bias (engineering sense of the world).
It it biased because an alternative  based on the two complementary method makes think harder specially for comparison. 
The bias is equal to 1023 and $e$ belongs [-1022,1023]. $F$ is the fraction (53 bits) $\sum_{n=1}^{p-1} bit_n \times 
2^{-n}$. The method consists to take the wanted $k$ add the bias and move it into the exponent part of the floating point representation, and let the machine interpret it like a double.
The method is efficient, fast and do not introduce any error or conversion. This method can be described by the following algorithm:

\begin{algorithm}[H]
 \KwData{$k$ signed integer}
 \KwResult{$2^k$ as double}
 $ k = (1023 + k) << 52 $\;
 \textbf{return} interpret\_as\_double($k$)\;
 \caption{$2^k$ evaluation algorithm. Note the operation  interpret\_as\_double interprets $k$ as a double it is not a cast operation.}
\end{algorithm}

\subsection{Boundary limits}

The last step consists to fix the boundary limits, this step is mandatary and it introduces additional workflows and it is sometime neglected 
in previous exponential study [pique pour COSTAS]. The  boundary limits to respect are summarised in the table \ref{boundary}.

\begin{table}[ht]
\begin{center}
\begin{tabular}{l c c c c c c }
$x$                         & $-\infty$  &$+\infty$ & 0 & NaN & $> max$  & $< max$  \\
		          \hline
$e^x$                   &  0 & $+\infty$  & 1 & NaN & $+\infty$   & 0 \\
		             \hline
\end{tabular}
\caption{Boundary of the exponential \label{boundary}}
\end{center}
\end{table}%

Branching are impossible on SIMD architecture nevertheless it exists alternative using bit manipulation.
As described in the table \ref{boundary}.

\begin{algorithm}[H]
 \KwData{$x$ floating point number}
 \KwResult{$e^x$ with correct boundary condition (table \label{boundary})}
 \tcc{  inequality operator return false (0) or  true (-1)}
 $mask0 = \neg(|x| > max)$\;   
 $mask1 = x < max$\;
 $mask2 =  +\infty$\;
 \textbf{Compute}: $y = e^x$\;
 $y \,\, \&= mask0$\;
 $mask3  \,\, \&= \neg mask1$\;
 $y \,\, |= mask2$\;
 \textbf{return} $y$\;
 \caption{Boundary condition algorithm}
\end{algorithm}

This algorithm has been applied for the scalar and vectorial versions.

\section{Processor \& methods}
Perform a full review of processors is a huge work and it is outside the topic of this paper. We focus on the general execution of the processors, but still with enough details
to understand our results. Whatever the architecture of the chip, the execution of the binary code follows the same logic. Fetch/decode units read a stream of instructions
from the L1 instructions cache memory and decode them into a series of micro operations that are executed by the processor's parallel executions units.

\subsection{Intel SandyBridge and Broadwell architecture}
The SandyBridge and Broadwell architecture derived from the core2duo architecture (based on a Pentium M). Both architecture support the new set of 256 bit vectorial instructions 
named AVX and AVX2 (Broadwell only).  For both architectures, the instructions fetch unit bandwidth 
is limited to 16 bytes per clock cycle. The instructions decoding execution is complicated, it is split
between a predecoder and a decoder. The predecoder job is to detect where the instructions start, a hard task because the size of the instructions vary between 
1 to 15 bytes. The predecoder also identifies the additional field (if available) of the instructions (prefix, ModR/M, SIB, displacement and immediate). Then 4 decoders handle
the incoming instructions into 1 or more $\mu$ops. Only the first decoder can generate more than one $\mu$op. For SandyBridge, per cycle the decoders will generate 3 to 4  
$\mu$ops. On Broadwell the generation is stabilised to 4  $\mu$ops. The 16 bytes per clock cycle is a serious limitation, therefore both architecture have a cache memory
to avoid limitation of the 16 byte bandwidth. The effect of the cache memory can double the total size of  $\mu$ops generated: 32 bytes per cycle. 
%The cache is organised around 32 sets $\times$ 8 ways $\times$ 6 $\mu$ops.
%$3 caches lines of 6 $\mu$ops. can be allocated simultaneously for a maximum of 32 bytes of code per cycle. 
Both architecture have the possibilities to perform the fusion of instructions.
At this point, $\mu$ops are still in-order. They are now  stored in the re-order buffer (168 entries for SandyBridge and  192 entries for Broadwell) for the renaming of the register,  
the re-ordering $e.g.$ following a Tomasulo Algorithm, and in fine the reservation station  of 54 entries on Sandy Bridge and 60 on Broadwell respectively. At this last point the $\mu$ops will be executed on the execution units in out-of-order mode.
%The out of order execution is now performed on 6 ports on the SandyBridge and 8 port on the Broadwell, however the number of port dedicated for the vectorial addition, multiplications and FMA (Broadwell only) are
%equal to two, the port 0 and 1 respectively. 

The Sandy Bridge has six execution ports (or terminology execution pipelines). There are tree integer ALUs so that the most common integer operations can execute
 with a throughput of four instructions per clock cycle (port 0, 1 and 5). Two ports can handle memory read operations (port 2 and 3)
Port 4 is for memory write. Read/Write can be performed by port 2, 3 and 4 (write only) but the port 4 can not make address calculation.
The maximum throughput is one unfused $\mu$op on each port per clock cycle.
Port 0, 1 and 5 support usual 256 bit vector operations. There are separate ports for multiplication in general purpose registers and vector registers. 
The integer and floating point vector multiplier on port 0.  These two multipliers can run simultaneously and both are fully pipelined with a throughput of 1 vector operation per clock cycle.
%Integer division uses the floating point division unit on port 0. This is the only unit that is not pipelined.

The Broadwell architecture has 8 execution ports (or terminology execution pipelines).  There are four integer ALUs so that the most common integer operations can execute
 with a throughput of four instructions per clock cycle. There are three ports that can handle integer vector operations (port 0, 1 and 5).
 Two ports can handle branches (port 0 and 6).  Two ports can handle memory read operations (port 2 and 3), and one port can handle memory writes (port 4).
Two ports can handle floating point vector operations (port 0 and 1). The direct consequences  of this larger number of port for floating point operations 
is a better throughput for vectorial addition (0.8) and vectorial multiplication (0.5) compared to SandyBridge.

\subsection{IBM Power7 and Power8 architecture}
The Power8 is the last release of the IBM processor derived from the Power7.
As x86 architecture Power7/8 support vectorial instructions but limited to 128 bit width. 
For both architecture the Instruction Fetch Unit bandwidth is equal to 32 bytes per clock. Contrary to the X86 architecture the instructions are enconded in the POWER 32-bit
fixed-width RISC ISA. Therefore 8 inscriptions are pre-decoded into $\mu$ops by the IFU, and store in I-cache of 32 KB (4-way set associative  L1 cache for the Power7 and
8-way set associative  L1 cache). This operations is performed in 2 cycles. As X86 both architecture can performed fusion of instructions with more facility for the Power8
If the requesting thread is ready, the  $\mu$ops are bypassed directly the I-cache to the instructions buffer
still in order). The Power7 has a instructions completion/cycle of 6 compare to 8 of the Power8.

The  $\mu$ops will be managed by the Instructions Sequencing Unit (ISU) doing the renaming in out-of order mode and the dispatch in the various issue queues to
the executions pipelines. After renaming and the dispatching the $\mu$ops (at least the compute one) are transferred to the UniQueue (as the reservation station fro X86). 
the UniQueue is implemented as 48-entry queue  (power7) or 64-entry queue (power8) and split into two halves.

The Power7 has 12 executions pipelines, but XXX are dedicated per half UniQueue, but  only  3 instructions per cycle can be executed, 
one fixed-point instructions on the Fixed-Point Unit, one load, store or simple  fixed-point instruction (Addition and logical instructions) on the Load/Store unit (LSU). One load or simple-fixed instruction on the Load unit (LU) and one scalar/vector instructions to the Vector Scalar Unit. 

The Power8 has 16 execution pipelines, but  6 are dedicated per half UniQueue, but  only  4 instructions per cycle can be executed, one fixed-point instructions on the Fixed-Point Uni,
one load, store or simple  fixed-point instruction (Addition and logical instructions) on the Load/Store unit (LSU)  and one scalar/vector instructions to the Vector Scalar Unit. The 4 other executions pipelines are dedicated to the cryptography, the branch execution, the condition logical and the decimal floating point operations. 


\subsection{Latency, throughput definitions}

The latency of an instruction is the delay that the instruction generates in a dependency chain. 
For example, a reciprocal throughput of 2 for FMUL means that a new FMUL instruction can start executing
2 clock cycles after a previous FMUL. A reciprocal throughput of 0.33 for ADD means that the execution units can handle 3 integer additions per clock cycle.

The throughput is the maximum number of instructions of the same kind that can be executed per clock cycle
when the operands of each instruction are independent of the preceding instructions.

The latency and the throughput of the main instructions for all platforms are reported in the table \label{latencyvendor}.

\subsection{Precision}

The precision computed by the Unit of Least Precision (ULP).
The original definition is: \textit{ulp(x) is the gap between the two floating-point number nearest $x$, even is $x$ is one of them.}
As we described previously the precision for the exponential implementation will depend only on the error of the polynomial evaluation.
Because the error on the evaluation on the $2^k$ used the hardware representation of the floating point and the boundaries conditions 
only introduce bit  manipulation trick.  The ULP has been computed using external library, here the boost library more specially the boost::math
package.

\subsection{measurement tool}

Measure the throughput/latency is not trivial specially for the latency. A direct measurement is not trivial due 
to the large number of variables which may impact the measurements. 
Therefore, the approach used within this study consists of performing indirect measurements by mapping the instructions associated to their
mnemonics into a for loop whose unroll factor was parameterizable (between 1 and 5). 
To avoid introducing some operation throughput effect which would corrupt the measurement of latency, a dependency between instructions 
throughout the loop iterations has been artificially enforced. 

Within this study, all benchmarks were compiled using GCC and repeated 100 times. The results of this experiment are reported in Figure \ref{fig.LATENCY_OPS} in function of the used unroll factor.  
The experimental data has been fit to a linear distribution ($y=ax+b$ where $a$ corresponds to the slope of the curve which is equal to 100 times the actual 
latency of the instruction).  Latency measurements have been carried out for all basic instructions +, $\times$, $/$ and FMA and compare to the 
vendor results to validate our method with success. Latency of the previous instructions are reported in the table \ref{latencyvendor}.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.7]{platency.eps} %\vspace{-1cm}
\caption{Value of latencies using a linear approximation for vectorial double precision instructions on Power8: $+$. 
The slop $a$ represents the latency of the instructions. The residual $b$ of 60 cycle in 0, corresponds to the the additional workload in cycle introduced 
by the program/processor. 
\label{fig.LATENCY_OPS}}
\end{center}
\end{figure}

\begin{table}[ht]
\caption{Latency/Throughput add/mul/fma on the Broadwell architecture. \label{latencyvendor}}
\begin{center}
\begin{tabular}{l c c c c c c }
			& \multicolumn{2}{c}{SandyBridge} & \multicolumn{2}{c}{Broadwell}  & \multicolumn{2}{c}{Power 7/8}\\ 
                         & Thr.  & Lat. & Thr. & Lat. & Thr. & Lat.  \\
		          \hline
add                   &  1 & 3  &   0.8 & 3 &  1 & 6     \\
mul                   &  1 & 5  &   0.5 & 5 &  1 & 6   \\
FMA                 &   -  & -  &   0.5 & 5  &  1 & 6   \\
		             \hline
\end{tabular}
\end{center}
\end{table}%

A full review  of all x86 instructions can be found in [CITE agner] where fragmented information can be founded in [CITE p7 and P8] paper.
To conclude, Intel has released in the last years the IACA tool [CITE]. This tools was nice to perform latency and throughput analysis, and
do prediction on several Intel processor target. Unfortunately the tools is not anymore maintained since 2012 date of the last release. 
However, we utilize the tool to generate Direct Acyclic Graph of the polynomial evaluation on the Broadwell platform, figure \ref{DAG}

\subsection{Programming model}

Program polynomial evaluation and $e^x$ is not trivial because the code can not be polluted by additional workload, and useless
instructions. A solution will be to write directly in assembly language, the solution is conceivable although is time consuming. 
An alternative is meta-programming associated to recursive algorithm. It simplify the generation of all polynomial evaluation
as soon as all method has been coded. Moreover as the algorithms are generics they can be plugged to any DSL to generate 
a SIMD code, it is what we did. The algorithm are successively instantiated with the basic type double and a generic vector class coming from the Cyme library.
To control the quality of our ASM at least on x86 platform we extract the DAG (Figure \ref{DAG}) using the IACA tool. Per example for the evaluation
of the Horner method of the first order on a polynomial of degree 10. The match is perfect between the theory and the generated assembly.

\begin{figure}
\subfloat[]
{
%\resizebox{.1\textwidth}{.9\textwidth}{%
\begin{tikzpicture}[>=latex',line join=bevel,scale=0.3]
%%
\node (11) at (213.0bp,18.0bp) [draw=cyan,fill=cyan,circle,scale=0.3] {11. mov};
  \node (10) at (213.0bp,90.0bp) [draw=pink,fill=pink,circle,scale=0.3] {10. FMA};
  \node (1) at (213.0bp,738.0bp) [draw=pink,fill=pink,circle,scale=0.3] {1. FMA};
  \node (0) at (213.0bp,810.0bp) [draw=cyan,fill=cyan,circle,scale=0.3] {0. mov};
  \node (3) at (213.0bp,594.0bp) [draw=pink,fill=pink,circle,scale=0.3] {3. FMA};
  \node (2) at (213.0bp,666.0bp) [draw=pink,fill=pink,circle,scale=0.3] {2. FMA};
  \node (5) at (213.0bp,450.0bp) [draw=pink,fill=pink,circle,scale=0.3] {5. FMA};
  \node (4) at (213.0bp,522.0bp) [draw=pink,fill=pink,circle,scale=0.3] {4. FMA};
  \node (7) at (213.0bp,306.0bp) [draw=pink,fill=pink,circle,scale=0.3] {7. FMA};
  \node (6) at (213.0bp,378.0bp) [draw=pink,fill=pink,circle,scale=0.3] {6. FMA};
  \node (9) at (213.0bp,162.0bp) [draw=pink,fill=pink,circle,scale=0.3] {9. FMA};
  \node (8) at (213.0bp,234.0bp) [draw=pink,fill=pink,circle,scale=0.3] {8. FMA};
  \draw [->] (5) ..controls (213.0bp,423.98bp) and (213.0bp,414.71bp)  .. (6);
  \draw [->] (2) ..controls (213.0bp,639.98bp) and (213.0bp,630.71bp)  .. (3);
  \draw [->] (7) ..controls (213.0bp,279.98bp) and (213.0bp,270.71bp)  .. (8);
  \draw [->] (6) ..controls (213.0bp,351.98bp) and (213.0bp,342.71bp)  .. (7);
  \draw [->] (4) ..controls (213.0bp,495.98bp) and (213.0bp,486.71bp)  .. (5);
  \draw [->] (8) ..controls (213.0bp,207.98bp) and (213.0bp,198.71bp)  .. (9);
  \draw [->] (1) ..controls (213.0bp,711.98bp) and (213.0bp,702.71bp)  .. (2);
  \draw [->] (9) ..controls (213.0bp,135.98bp) and (213.0bp,126.71bp)  .. (10);
  \draw [->] (0) ..controls (213.0bp,783.98bp) and (213.0bp,774.71bp)  .. (1);
  \draw [->] (3) ..controls (213.0bp,567.98bp) and (213.0bp,558.71bp)  .. (4);
  \draw [->] (10) ..controls (213.0bp,63.983bp) and (213.0bp,54.712bp)  .. (11);
%
\end{tikzpicture}
%}
}
\subfloat[]
{
\begin{tikzpicture}[>=latex',line join=bevel,,scale=0.3]
%%
\node (11) at (229.0bp,519.0bp) [draw=pink,fill=pink,circle,scale=0.3] {11. $\times$};
  \node (10) at (372.0bp,283.0bp) [draw=cyan,fill=cyan,circle,scale=0.3] {10. mov};
  \node (13) at (130.0bp,639.0bp) [draw=cyan,fill=cyan,circle,scale=0.3] {13. mov};
  \node (12) at (227.0bp,401.0bp) [draw=pink,fill=pink,circle,scale=0.3] {12. $\times$};
  \node (15) at (131.0bp,401.0bp) [draw=pink,fill=pink,circle,scale=0.3] {15. FMA};
  \node (14) at (130.0bp,519.0bp) [draw=pink,fill=pink,circle,scale=0.3] {14. FMA};
  \node (17) at (280.0bp,161.0bp) [draw=pink,fill=pink,circle,scale=0.3] {17. FMA};
  \node (16) at (158.0bp,283.0bp) [draw=pink,fill=pink,circle,scale=0.3] {16. FMA};
  \node (18) at (280.0bp,41.0bp) [draw=cyan,fill=cyan,circle,scale=0.3] {18. mov};
  \node (1) at (35.0bp,639.0bp) [draw=pink,fill=pink,circle,scale=0.3] {1. FMA};
  \node (0) at (35.0bp,752.0bp) [draw=cyan,fill=cyan,circle,scale=0.3] {0. mov};
  \node (3) at (38.0bp,401.0bp) [draw=pink,fill=pink,circle,scale=0.3] {3. FMA};
  \node (2) at (35.0bp,519.0bp) [draw=pink,fill=pink,circle,scale=0.3] {2. FMA};
  \node (5) at (280.0bp,283.0bp) [draw=pink,fill=pink,circle,scale=0.3] {5. $\times$};
  \node (4) at (248.0bp,639.0bp) [draw=pink,fill=pink,circle,scale=0.3] {4. $\times$};
  \node (7) at (372.0bp,639.0bp) [draw=pink,fill=pink,circle,scale=0.3] {7. FMA};
  \node (6) at (372.0bp,752.0bp) [draw=cyan,fill=cyan,circle,scale=0.3] {6. mov};
  \node (9) at (372.0bp,401.0bp) [draw=pink,fill=pink,circle,scale=0.3] {9. FMA};
  \node (8) at (372.0bp,519.0bp) [draw=pink,fill=pink,circle,scale=0.3] {8. FMA};
  \draw [->,solid] (17) ..controls (280.0bp,109.5bp) and (280.0bp,100.4bp)  .. (18);
  \draw [->,solid] (4) ..controls (267.3bp,594.26bp) and (273.1bp,577.62bp)  .. (276.0bp,562.0bp) .. controls (291.24bp,479.97bp) and (287.72bp,381.97bp)  .. (5);
  \draw [->,solid] (14) ..controls (130.44bp,467.23bp) and (130.52bp,458.16bp)  .. (15);
  \draw [->,solid] (16) ..controls (204.58bp,236.18bp) and (225.05bp,216.05bp)  .. (17);
  \draw [->,solid] (4) ..controls (240.85bp,593.6bp) and (238.66bp,579.97bp)  .. (11);
  \draw [->,solid] (7) ..controls (372.0bp,588.43bp) and (372.0bp,575.18bp)  .. (8);
  \draw [->,solid] (6) ..controls (372.0bp,707.13bp) and (372.0bp,697.21bp)  .. (7);
  \draw [->,solid] (15) ..controls (141.65bp,354.23bp) and (143.95bp,344.36bp)  .. (16);
  \draw [->,solid] (2) ..controls (36.172bp,472.7bp) and (36.54bp,458.45bp)  .. (3);
  \draw [->,solid] (8) ..controls (372.0bp,472.7bp) and (372.0bp,458.45bp)  .. (9);
  \draw [->,solid] (3) ..controls (78.351bp,360.99bp) and (100.96bp,339.14bp)  .. (16);
  \draw [->,solid] (13) ..controls (130.0bp,590.01bp) and (130.0bp,581.05bp)  .. (14);
  \draw [->,solid] (10) ..controls (336.87bp,236.18bp) and (323.75bp,219.07bp)  .. (17);
  \draw [->,solid] (5) ..controls (280.0bp,238.16bp) and (280.0bp,225.98bp)  .. (17);
  \draw [->,solid] (9) ..controls (372.0bp,356.71bp) and (372.0bp,345.03bp)  .. (10);
  \draw [->,solid] (12) ..controls (200.65bp,355.7bp) and (192.43bp,341.89bp)  .. (16);
  \draw [->,solid] (0) ..controls (35.0bp,705.68bp) and (35.0bp,694.02bp)  .. (1);
  \draw [->,solid] (11) ..controls (228.19bp,470.82bp) and (228.0bp,460.08bp)  .. (12);
  \draw [->,solid] (1) ..controls (35.0bp,592.2bp) and (35.0bp,577.16bp)  .. (2);
%
\end{tikzpicture}
}
\subfloat[]
{
\begin{tikzpicture}[>=latex',line join=bevel,scale=0.3]
%%
\node (11) at (44.0bp,446.0bp) [draw=cyan,fill=cyan,circle,scale=0.3] {11. mov};
  \node (10) at (445.0bp,580.0bp) [draw=pink,fill=pink,circle,scale=0.3] {10. FMA};
  \node (13) at (248.0bp,446.0bp) [draw=cyan,fill=cyan,circle,scale=0.3] {13. mov};
  \node (12) at (44.0bp,307.0bp) [draw=pink,fill=pink,circle,scale=0.3] {12. FMA};
  \node (15) at (146.0bp,307.0bp) [draw=cyan,fill=cyan,circle,scale=0.3] {15. mov};
  \node (14) at (248.0bp,307.0bp) [draw=pink,fill=pink,circle,scale=0.3] {14. FMA};
  \node (17) at (322.0bp,44.0bp) [draw=pink,fill=pink,circle,scale=0.3] {17. FMA};
  \node (16) at (228.0bp,173.0bp) [draw=pink,fill=pink,circle,scale=0.3] {16. FMA};
  \node (19) at (580.0bp,307.0bp) [draw=cyan,fill=cyan,circle,scale=0.3] {19. mov};
  \node (18) at (555.0bp,446.0bp) [draw=pink,fill=pink,circle,scale=0.3] {18. $\times$};
  \node (1) at (559.0bp,932.0bp) [draw=pink,fill=pink,circle,scale=0.3] {1. FMA};
  \node (0) at (559.0bp,1044.0bp) [draw=cyan,fill=cyan,circle,scale=0.3] {0. mov};
  \node (3) at (289.0bp,816.0bp) [draw=cyan,fill=cyan,circle,scale=0.3] {3. mov};
  \node (2) at (525.0bp,816.0bp) [draw=pink,fill=pink,circle,scale=0.3] {2. FMA};
  \node (5) at (397.0bp,307.0bp) [draw=pink,fill=pink,circle,scale=0.3] {5. $\times$};
  \node (4) at (466.0bp,700.0bp) [draw=pink,fill=pink,circle,scale=0.3] {4. FMA};
  \node (7) at (716.0bp,446.0bp) [draw=cyan,fill=cyan,circle,scale=0.3] {7. mov};
  \node (6) at (339.0bp,173.0bp) [draw=pink,fill=pink,circle,scale=0.3] {6. $\times$};
  \node (9) at (648.0bp,173.0bp) [draw=pink,fill=pink,circle,scale=0.3] {9. FMA};
  \node (8) at (716.0bp,307.0bp) [draw=pink,fill=pink,circle,scale=0.3] {8. FMA};
  \draw [->,solid] (18) ..controls (492.54bp,390.84bp) and (464.25bp,366.31bp)  .. (5);
  \draw [->,solid] (18) ..controls (566.61bp,381.37bp) and (568.9bp,368.82bp)  .. (19);
  \draw [->,solid] (15) ..controls (176.84bp,256.35bp) and (188.88bp,236.98bp)  .. (16);
  \draw [->,solid] (18) ..controls (570.99bp,576.9bp) and (584.84bp,728.08bp)  .. (573.0bp,856.0bp) .. controls (572.18bp,864.82bp) and (570.84bp,874.14bp)  .. (1);
  \draw [->,solid] (10) ..controls (485.62bp,530.25bp) and (500.71bp,512.15bp)  .. (18);
  \draw [->,solid] (6) ..controls (330.26bp,258.85bp) and (328.92bp,311.31bp)  .. (339.0bp,356.0bp) .. controls (353.78bp,421.53bp) and (390.18bp,490.39bp)  .. (10);
  \draw [->,solid] (1) ..controls (545.05bp,884.22bp) and (541.99bp,873.95bp)  .. (2);
  \draw [->,solid] (11) ..controls (44.0bp,391.77bp) and (44.0bp,376.3bp)  .. (12);
  \draw [->,solid] (0) ..controls (559.0bp,999.87bp) and (559.0bp,990.83bp)  .. (1);
  \draw [->,solid] (8) ..controls (689.62bp,254.8bp) and (679.36bp,234.87bp)  .. (9);
  \draw [->,solid] (14) ..controls (239.76bp,251.62bp) and (237.85bp,239.01bp)  .. (16);
  \draw [->,solid] (5) ..controls (410.95bp,221.12bp) and (413.25bp,167.3bp)  .. (396.0bp,124.0bp) .. controls (389.2bp,106.93bp) and (376.79bp,91.366bp)  .. (17);
  \draw [->,solid] (3) ..controls (347.72bp,777.18bp) and (392.34bp,748.44bp)  .. (4);
  \draw [->,solid] (9) ..controls (586.61bp,205.32bp) and (551.84bp,228.33bp)  .. (531.0bp,258.0bp) .. controls (473.52bp,339.85bp) and (454.45bp,458.04bp)  .. (10);
  \draw [->,solid] (18) ..controls (544.94bp,570.41bp) and (534.64bp,696.76bp)  .. (2);
  \draw [->,solid] (2) ..controls (501.25bp,769.1bp) and (494.62bp,756.29bp)  .. (4);d
  \draw [->,solid] (17) ..controls (377.93bp,83.18bp) and (400.95bp,102.52bp)  .. (417.0bp,124.0bp) .. controls (477.55bp,205.06bp) and (517.78bp,316.76bp)  .. (18);
  \draw [->,solid] (18) ..controls (451.15bp,422.98bp) and (368.62bp,405.8bp)  .. (297.0bp,392.0bp) .. controls (208.31bp,374.91bp) and (178.05bp,395.85bp)  .. (97.0bp,356.0bp) .. controls (91.648bp,353.37bp) and (86.437bp,350.03bp)  .. (12);
  \draw [->,solid] (7) ..controls (716.0bp,393.9bp) and (716.0bp,374.42bp)  .. (8);
  \draw [->,solid] (5) ..controls (334.49bp,262.88bp) and (305.62bp,241.97bp)  .. (281.0bp,222.0bp) .. controls (276.49bp,218.34bp) and (271.86bp,214.42bp)  .. (16);
  \draw [->,solid] (13) ..controls (248.0bp,391.77bp) and (248.0bp,376.3bp)  .. (14);
  \draw [->,solid] (18) ..controls (615.96bp,394.95bp) and (640.38bp,374.59bp)  .. (662.0bp,356.0bp) .. controls (667.62bp,351.16bp) and (673.53bp,346.0bp)  .. (8);
  \draw [->,solid] (5) ..controls (372.75bp,250.8bp) and (367.38bp,238.59bp)  .. (6);
  \draw [->,solid] (3) ..controls (244.81bp,711.63bp) and (167.61bp,534.97bp)  .. (93.0bp,392.0bp) .. controls (86.463bp,379.47bp) and (78.964bp,366.16bp)  .. (12);
  \draw [->,solid] (4) ..controls (457.65bp,652.08bp) and (456.0bp,642.81bp)  .. (10);
  \draw [->,solid] (16) ..controls (265.13bp,121.83bp) and (278.34bp,103.98bp)  .. (17);
  \draw [->,solid] (12) ..controls (87.475bp,227.8bp) and (127.44bp,165.72bp)  .. (175.0bp,124.0bp) .. controls (203.6bp,98.917bp) and (241.53bp,78.783bp)  .. (17);
  \draw [->,solid] (18) ..controls (529.27bp,533.04bp) and (513.76bp,581.81bp)  .. (498.0bp,624.0bp) .. controls (494.32bp,633.85bp) and (490.08bp,644.3bp)  .. (4);
  \draw [->,solid] (18) ..controls (461.37bp,408.97bp) and (395.19bp,382.33bp)  .. (339.0bp,356.0bp) .. controls (324.67bp,349.29bp) and (309.36bp,341.47bp)  .. (14);
  \draw [->,solid] (18) ..controls (606.89bp,393.91bp) and (620.81bp,375.44bp)  .. (629.0bp,356.0bp) .. controls (646.87bp,313.59bp) and (650.6bp,260.89bp)  .. (9);
%
\end{tikzpicture}
}
\caption{Broadwell mnemonic DAG of the polynomial evaluation for three methods of evaluation (latency/throughput), (a) classical Horner (50.0/3.55 [cycle]), (b) Estrin (22.68/2.90 [cycle]), (c)  Estrin$^6 \times$BruteForce$^4$ (28.94/3.11 [cycle])  \label{DAG}}
\end{figure}


\section{Results}


\subsection{polynomials}
build th. model difficult, to make a prediction [cite simulator] outside our knowledge.
Simple model easy for latency and the Horner method order 1...

horner order 1 -> 10 mul/add or FMA  with dependency = 10 * latency of mul/add or FMA... it works all platform see table..
produce of two quadratic horner large degree fix the time 6* latency of mul/add or FMA... + the final mul (dependency) it works.

\subsection{exponentials}

give results compare to vendors intel svml and mass



\begin{figure}[h]
\mbox{
\hspace{-2cm}
\includegraphics[scale=0.7]{allht_scalar.eps} 
\hspace{-2.5cm}
\includegraphics[scale=0.7]{allht_vector.eps}
}
\caption{Latency/Throughput for  all architectures, scalar version left and vectorial version right}
\end{figure}

\begin{figure}[h]
\mbox{
\hspace{-2cm}
\includegraphics[scale=0.7]{hw_histo_vector_l.eps} 
\hspace{-2.5cm}
\includegraphics[scale=0.7]{hw_histo_vector_t.eps}
}
\caption{Latency and Throughput frequency of the vectorial version. The analysis is done for the original polynomial or the factorization associated. Sampling interval of 1 for the latency and 0.1 for the throughput.}
\end{figure}


\begin{figure}[h]
\mbox{
\hspace{-2cm}
\includegraphics[scale=0.7]{all_precision_scalar.eps} 
\hspace{-2.5cm}
\includegraphics[scale=0.7]{all_precision_vector.eps}
}
\caption{Histogram of the precision of all polynomial evaluation for scalar version (left) and vector version (right). The bar of 
the histogram is the total number os polynomial evaluations for a given ULP}
\end{figure}



\begin{table}[ht]
\begin{center}
\begin{tabular}{l l c c c  l c c  c }
\hline
		     & & \multicolumn{3}{c}{scalar} & &  \multicolumn{3}{c}{vector} \\
		     &  &   \multicolumn{3}{c}{Throughput Criteria} &   &  \multicolumn{3}{c}{Throughput Criteria} \\
Platform        & Al.                                            & Th.  & La.      & ULP  & Al.                & Th.   & La.     & ULP \\ 	
SandyBridge & $P^{10}_e$                             & 6.73 & 30.20  & 3       & $P^{10}_e$  & 6.89 & 35.81& 3 \\
Broadwell         & $P^6_{h^{1}}P^4_{h^{1}}$      & 3.13 & 35.03  & 8           & $P^{10}_e$  & 2.90 & 22.69 & 2 \\
Power7         & $P^{10}_e$                             & 6.60  & 26.02  & 2      & $P^{10}_e$  & 6.70 & 16.94  & 3 \\  
Power8          & $P^{10}_e$                            &  5.31  & 26.11 & 2       &$P^{10}_e$  & 7.58  & 17.03 & 2 \\
		     &  &   \multicolumn{3}{c}{Latency Criteria} &   &  \multicolumn{3}{c}{Latency Criteria} \\
SandyBridge & $P^6_eP^4_e$                      & 7.12 & 28.21  & 8        & $P^6_eP^4_e$  & 7.21 & 29.89 & 8 \\
Broadwell         & $P^4_bP^2_bP^2_eP^2_e$  & 3.14 & 26.07  & 9        & $P^{10}_e$  & 2.90 & 22.69 & 3 \\
Power7         & $P^{10}_e$                             & 6.60  & 26.02  & 2      & $P^{10}_e$  & 6.70 & 16.94  & 3 \\  
Power8          & $P^{10}_e$                            &  5.31  & 26.11 & 2       &$P^{10}_e$  & 7.58  & 17.03 & 2 \\
\hline
\end{tabular}
\end{center}
\caption{Best Latency/throughput [cycle] polynomial evaluation on all platforms. The criteria indicates the sort the tuple (throughput, latency, ulp), 
on a specific part \label{LTR_EXP}}
\end{table}%

\section{Conclusions}

factorisation is good

\end{document}
